Javascript (linguagem voltada a objetos)

Variáveis
- no javascript moderno, pode-se utiliza  "var" para se referir a uma variável ou então "let."
	ex.: 	var n1 = 5; ->	a variável "n1" vai receber o valor "5", ou seja, trata-se de uma variável numérica.

Obs: exitem diversos tipos de variáveis em javascript, as primordiais e mais básicas são:

	-number: 	números no geral (5 ,18, 0.5, 3.14, etc)
	-string:	cadeias de caracteres ("google", 'javascript',`Maria`, "021.951.503-43", etc).
	-boolean:	apresenta apenas dois valores "true" e "false"

- string: variável que recebe texto. Podem ser escritas de três formas, cada uma com seu significado.
	ex.: 	var s1 ="javascript";
		var s2 ='curso em vídeo';
		var s3 =`guanabara`;

- identificadores: é a maneira de identificar uma variável em javascript e obedece algumas regras:

	.podem começar com letra, $ ou _.
	.NÃO pode começar com números.
	.é possível usar letras ou números.
	.é possível usar acentos e símbolos.
	.não podem conter espaços (usar "_" no lugar).
	.NÃO pode usar palavras reservadas (function, alert, var, etc).

	.dicas para a criação de variáveis:
		
		-maiúsculas e minúsculas fazem diferença (Casa é diferente de casa).
		-tente escolher nomes coerentes para as variáveis.
		-evite se tornar um "programador alfabeto" ou um "programador contador", ou seja, que criam variáveis apenas com números ou letras sem coerência
		com o dado a ser armazenado na variável.

Obs: para utilizar o NODE.JS (ou o BASH) no VScode, basta abrir o terminal (ou ctrl+shift+') e digitar "node", sem as aspas. Para sair do NODE no terminal aberto
basta digitar ".exit" e para sair do terminal aberto, basta digitar "exit" e depois dar "enter". Para limpar a tela de um terminal (limpar e não sair), basta apertar
"ctrl+L".

- typeof: comando que retorna o tipo de variável. Quando uma variável é criada, ela não é predefinida de um tipo. Ela ganha aquele tipo a depender do valor recebido
por ela. Ex.: no node do terminal do VScode, atribua o valor "200" a uma vatiável qualquer "n" (var n = 200). Em seguida digite "typeof n" e será retornado 'number'.

Obs: se uma variável receber o valor de um número entre aspas ("200"), o programa entenderá esse número como sendo uma string.

Explicando o código

	<script> //as mensagens abaixo serão exibidas primeiramente        
        	var nome = window.prompt('Qual o seu nome?')
        	//tudo o que for recebido em window.prompt será recebido pela variável chamada "nome"//
        	window.alert ('É um prazer em te conhecer, ' + nome + '!'); // "+" concatenação
    	</script>

<script></script> ->				local onde será inserido (dentro do arquivo de html) o código de javascript
var nome = window.prompt('Qual o seu nome?')	indica que, dentro do prompt estabelecido (window.prompt), o que for digitado será armazenado (atribuído) em uma 
						variável chamada "nome"
window.alert ('É um prazer em te conhecer, ' 
+ nome + '!') ->				comando para a página web exibir algo que, nesse caso, por meio de concatenação (+) será oq que estiver armazenado na
						variável "nome" e um ponbto de exclamação (!).

Obs: o javascript possui alguns comandos básicos:

	-window.alert('Minha primeira mensagem!'); ->	exibe uma mensagem de alerta (não pergunta nada. Apenas alerta)
        -window.confirm('Está gostando de JS?'); ->	exibe uma pergunta e o usuário precisa escolher uma opção
        -window.prompt('Qual o seu nome?') ->		exibe um espaço para o usuário inserir algo
	-document.write('Bem-vindo!') ->		escreve no body do arquivo html o que está no parênteses
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Concersão de dados em javascript

-ao inserir um dado por meio de um prompt, talvez seja necessário especificar ao javascript o seu tipo. Ex.:

	<script>
		var n1 = window.prompt('Digite um número');
        	var n2 = window.prompt('Digite outro número');
        	var s = n1 + n2;        
        	window.alert ('A soma dos valores é ' + s + '!');         
	</script>

No exemplo acima, supondo que foi inserido "4" na primeira variável e "2" na segunda, o "window.alert" retornará na tela "42" ao invés de "6". Isso porque ele entende 
o que foi inserido como uma string ao invés de números, concatenando (juntando) os dois ao invés de somá-los. Para corrigir o erro e atingir o objetivo de soma, será 
necessário transformar de string para número. A conversão é feita já na declaração da variável e existem três formas basicamente:

	-Number.parseInt(n) ->		para tranformar em número inteiro (sem vírgula)
						.var n1 = Number.parseInt(window.prompt('Digite um número'));
						.var n2 = Number.parseInt(window.prompt('Digite outro número'));
	-Number.parseFloat(n) ->	para tranformar em número real (com vírgula)
						.var n1 = Number.parseFloat(window.prompt('Digite um número'));
						.var n2 = Number.parseFloat(window.prompt('Digite outro número'));
	-Number(n) ->			para tranformar em número a depender do javascript (o que ele entender que faz sentido com o que foi inserido)
						.var n1 = Number(window.prompt('Digite um número'));
						.var n2 = Number(window.prompt('Digite outro número'));

Também é possível transformar de número para string:

	-String(n)
		.window.alert('A soma dos valores é ' + String(s) + '!');
		
	-n.toString()
		.window.alert('A soma dos valores é ' + s.toString() + '!');

Nos exemplos acima, a variável "s" é um número resultante da soma de dois outros números. Caso deseje que ele seja considerado uma string, é preciso fazer a conversão.

Template string

Observe o código abaixo:

	<script>
		var nome ='Filipe';
		var idade = 41;
		var nota = 5.5;
	</script>

Para dar um comando retornando os três valores numa setença, é possível da seguinte maneira:

	<script>
		var nome ='Filipe';
		var idade = 41;
		var nota = 5.5;
		window.alert ('O aluno ' + nome + ' com '+ idade + ' anos tirou a nota '+ nota)
	</script>

No exemplo acima, o texto corrido está entre aspa simples e, por meio de concatenação, as respectivas variáveis são inseridas (nome, idade e nota). Porém, existe uma
forma mais prática e simples de compreender de inserir as variáveis por meio de template strings:

	<script>
		var nome ='Filipe';
		var idade = 41;
		var nota = 5.5;
		window.alert(`O aluno ${nome} com ${idade} anos tirou a nota ${nota}`)
	</script>

No caso, o template string é iniciado e finalizado pelo sinal de crase (`) e utiliza a estrutura ${} (placeholder) para inserir determinada variável.

Formatando strings: considere uma string qualquer "s" e um número qualquer "n"

	-s.lenght ->				quantos caracteres a string "s" tem
	-s.to UpperCase() ->			todos os caracteres da string "s" ficam MAIÚSCULOS
	-s.toLowerCase() ->			todos os caracteres da string "s" ficam minúsculos
	-n.toFixed(2) ->			em numeros reais, estabeklece a quantidades de casas decimais a aparecer. Nesse caso, duas.
	-n.toFixed(2).replace('.', ',')		estabelece duas casas decimais e altera o "." (ponto) po "," (vírgula)
	-n.toLocaleString('pt-br', {style: 'currency', currency: 'BRL'}) ->	vai mostra o número em forma da moeda local ('currency') estabelecida nos parâmetros,
										no caso "real brasileiro" (currency: 'BRL')
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Operadores

-aritméticos (números)

	.+ ->	adição
	.- ->	subtração
	.* ->	multiplicação
	./ ->	divisão inteira. Ex.: 5 / 2 = 2.5
	.% ->	resto da divisão inteira. O que sobre de resto em um divisão inteira. Ex.: 5 % 2 = 1
	.** ->	potência. Ex.: 5 ** 2 = 25

Obs: precedência de operadores -> 5 + 3 / 2 = 6.5. Caso deseje calcular o "5 + 3" antes da divisão, utiliza-se o parênteses (5+3) /2 = 4

	.ordem de precedência: "()" --> "**" --> "*" --> "/" --> "%" --> "+" --> "-"

-atribuição

	.= ->			utilizado para atribuir dados em alguma variável. Ex.: var a = 5+3 (lê-se "variável a recebe o valor de 5 + 3")
	.auto-atribuição ->	var n = 3	--> o valor da variável n é 3
				n = n + 4
				n = 7		--> o novo valor de n é 7
	.simplificação ->		var n = 3
				n = n + 4 ou n+= 4	--> a simplificação pode ser ralizada quando há auto-referência. No caso, a variável n
				n = 7 
	.incremento ->		var n = 3	--> o valor inicial é 3
				n++		--> o novo valor é 4 
				n--		--> o novo valor é 2
-relacionais: o resultado da operação sempre será um valor booleano (true ou false)

	.>	maior que
	.<	menor que
	.>=	maior ou igual a
	.<=	menor ou igual a
	.==	igual a (avalia apenas o valor). Ex.: 5 (number) == '5' (string) --> true
	.===	idêntico irrestrito (mesmo valor e mesmo tipo). Ex.: 5 (number) == '5' (string) --> false
	.!=	diferente de (avalia apenas o valor). Ex.: 5 (number) != '5' (string) --> false
	.!==	desigual restrito (avalia o valor e o tipo). Ex.: 5 (number) == '5' (string) --> true (o valor é igual, mas o tipo é difrente)

-lógicos

	.!	negação:	utilizado para inverter o valor booleano de determinada expressão. Geralmente utilizado quando exite maior incidência de "não".
	.&&	conjunção (e)
	.||	disjunção (ou)

Obs: precedência de operadores lógicos ! --> && --> ||

-ternários: chama-se assim por possuir três partes. A primeira se trata de um teste, a segunda mostra o que será retornado caso o teste seja verdadeiro e o terceiro
mostra o que será retornado caso o teste seja falso

	.teste ? true : false. Ex.: média >= 7.0 ? "Aprovado" : "Reprovado"

--------------------------------------------------------------------------------------------------------------------------------------------------------------

DOM (Document Object Model)

-Árvore DOM
	
	.window (raiz):	tudo em javascript está contido em window. A janela do navegador é um objeto DOM. Exemplos de objetos contidos em window (não são os únicos):

		.location:	diz qual a localização do seu site, qual a URL, qual a página atual, qual a página anterior
		.history:	guarda de onde o usuário vem e pra onde vai, facilitando a navegação dentro do site
		.document:	diz qual o documento atual. Dentro do document existe outro objeto (o html):

			.html:	esqueleto do site. Possui basicamente dois "filhos"

				.head:	contém os meta dados e title
				.body:	é o que será exibido em tela (h1, p, div e etc)
		
					p:	parágrafo. Ainda pode ter um filho, como o strong (coloca determinada seção em negrito)]

Selecionando elementos dentro de uma árvore DOM

-por Marca (tag name):	getElementByTagName()[]

	.var p1 = window.document.getElementsByTagName('p')[0] 
	 window.document.write(p1.innerText)

		-var p1:		cria a variável p1
		-window:		elemento raiz do DOM
		-document:		documento filho de window
		-getElementsByTagName:	comando para selecionar por tag que no caso é a tag parágrafo (p)
		-('p'):			tag que será selecionada do documento que no caso é a tag parágrafo
		-[0]:			especifica de qual parágrafo se refere. No caso, refere-se ao primeiro parágrafo que aparece no documento [0]
		-write 
		(na segunda linha):	escreve no documento contido na tela (window.document)
		-(p1.innerText):	especifica o que será escrito em tela. No caso, será escrito o texto (somente o texto) contido (innerText) na variável p1. Por 
					exemplo, se no primeiro parágrafo do documento estiver escrito "Olá, mundo!", ele será escrito novamente. [EXTRA] O 
					HTMLElement.innerText pega o HTML inteiro, inclusive a tags filhas.

Obs: é possível fazer alterações de estilo por meio de javascript. Utilizando o exemplo acima, podemos fazer:

	.p1.style.color='blue':	altera a cor das letras do texto da variável p1 para azul, ou seja o texto do primeiro parágrafo.

-por ID:		getElementById()
	
-por Nome:		getElementsByName()[]
-por Classe:		getElementsByClassName()[]
-por Seletor (css):	querySelector() e querySelectorAll(). A seleção é feita por meio de elementos do css Ex.:

	var d = window.document.querySelector('div#msg') -->	está sendo selecionada a div que possui id ='msg' (se fosse uma "class", seria 'div.msg')
	var d = window.document.querySelectorAll('div') -->	está sendo selecionado todos os elementos div do documento

Obs: em css, um id é referenciado pelo "#" e uma class pelo ".".

Eventos DOM: ações que podem ser feitas com determinado elemento html

-mouseenter:	quando o cursor do mouse entra na área de determinado elemento
-mousemove:	quendo o curor do mouse se movimenta dentro da área de determinado elemento (disparado a cada movimento)
-mousedown:	quando o botão do mouse é clicado e segurado
-mouseup:	quando o botão do mouse clicado é soltado
-click:		quando ocorre um clique simples do mouse (sem segurar)
-mouseout:	quando o cursor do mouse, uma vez dentro da área de determinado elemento, sai

--------------------------------------------------------------------------------------------------------------------------------------------------------------

Funções: conjunto de linhas de código (bloco de código) que serão executadas apenas quando determinado evento ocorrer. São iniciadas com "function" seguida da ação e é
delimitada por "{}" como no modelo abaixo:

	.function ação(parâmetro){
		linha de código
	}

Detecção de erros em javascript: abra o devtools e localize um "x" vermelho no canto superior. Lá indicará onde está o erro (geralmente na linha anterior do que for 
apresentado.

Somando valores (análise de um código que soma valores inseridos pelo usuário)

	<body>
    		<h1>Somando valores</h1>
    		<input type="number" name="txtn1" id="txtn1"> + -->	cria um espaço para receber um input (informação/comando) do usuário, no caso, uma string
    		<input type="number" name="txtn2" id="txtn2">   -->	cria um espaço para receber um input (informação/comando) do usuário, no caso, uma string
    		<input type="button" value="somar" onclick="somar()">	cria um botão que receberá a função de somar os valores inseridos
    		<div id="resultado">Resultado</div>		-->	div destinada a receber o valor

    		<script>
       			function somar(){ 
        		var tn1 = window.document.getElementById('txtn1')// variável criada para receber o que for inserido no elemento input de id="txtn1" que no caso
										é o primeiro input
        		var tn2 = window.document.getElementById('txtn2')// variável criada para reber o que for inserido no elemento input de id="txtn1" que no caso é
										 o segundo input
        		var n1 = Number.parseFloat(tn1.value)// variável criada para transformar o valor, que no momento é string, em número. A função parseFloat 
								poderia ser substituída apenas pela função Number(). As duas são utilizadas para transformar uma string
								em número. O elemento dentro dos parênteses especifica que o valor de tn1, variável que receber o input 
								do usuário e possui por padrão valor de string, será alterado para número.
        		var n2 = Number.parseFloat(tn2.value)// variável criada para transformar o valor, que no momento é string, em número. A função parseFloat 
								poderia ser substituída apenas pela função Number(). As duas são utilizadas para transformar uma string
								em número. O elemento dentro dos parênteses especifica que o valor de tn1, variável que receber o input 
								do usuário e possui por padrão valor de string, será alterado para número.
        		var resultado = window.document.getElementById('resultado')// estabelece a correlação com o elemento div em questão e receberá qualquer 
										      informação inserido no elemento
        		var soma = n1 + n2// variável criada para receber o valor das duas variáveis numéricas transformadas das strings inseridas pelo usuário.
        		resultado.innerHTML =`A soma entra ${n1} e ${n2} é <strong>${soma}</strong>.`// para utilizar o placeholder, é preciso que o texto esteja entre
													aspas (``). A variável "resultado" terá seu texto interno 
													(innerText) alterado para o texto entre crases (``) e seus 
													placeholder, os quais fazem referência às respectivas variáveis 
													contidas dentro das {}.
			}
    		</script>
	</body>

Extra:

  	resultado.innerHTML = soma //chama a variável "soma" para compor o texto interno da div "resultado". Como a variável soma é a soma das duas 
	variáveis convertidas em números, será mostrada a soma dos dois valores inseridos nos inputs

--------------------------------------------------------------------------------------------------------------------------------------------------------------
Estruturas de controle

-if/else: permite executar um bloco de código seu uma condição for verdadeira e outro bloco caso seja falsa.

	.if:		define uma condição simples
	.if/else:	define uma condição de if... else
	.if/else if:	define múltiplas condições

-if/else ternário: é uma forma mais curta de escrever uma estrutura condicioanl if... else. Se for verdade, será retornado o que estiver na primeira posição (antes 
dos dois pontos). Se for uma condição falsa, será retornado o que estiver na segunda posição (depois dos dois pontos)

	const ideade = 18;
	const podeDirigir = idade>= 18? "Sim":"Não";	--> se "idade>=18" for verdade, então "Sim". Se for falsa, então "Não"
	console.log(podeDirigir); 			--> retornará "Sim", pois "18" é ">=18"

-switch: permite escolher entre váris opções com base no valor de uma expressão. Ex.:

	let diaSemana = 2;
	switch (diaSemana){
		case 1:
			console.log("Domingo");
			break;
		case 2:
			console.log("Segunda");
			break;
		default:
			console.log("Digite um valor válido")
	}


Condições em JavaScript

-if (condição simples)

	if(condição){
		true
	}

-if/else (condição composta)

	if(condição){
		true
	} else{
		false
	}
 
-if/else if (condição aninhada)

	if(condição1){ 
		bloco1
	} else{
		if(condição2){
			bloco2
		} else{
			bloco3
		} 
	}

Obs: para inserir comandos no arquivo de JavaScript, diferentemente de inserir no arquivo de HTML que utilizava o "window.document", é necessário utilizar o 
"console.log" como no exemplo abaixo    

	var idade = 65
	if(idade<16){					--> if
    		console.log('Não vota')
	} else if(idade<18){				--> condicional else if (condição aninhada)
        	console.log('Voto opcional')    
	} else if(idade>=18 && idade<=65){		--> condicional else if (condição aninhada)
    		console.log('Voto obrigatório')
	} else if (idade>65){				--> condicional else if (condição aninhada)
    		console.log('Voto opcional')
	}

-switch (condição múltipla): o "break" no final da cada case e do default é obrigatório

	switch(expressão){
		case valor1:
			break
		case valor2:
			break
		case valor3:
			break
		default:
			break	

--------------------------------------------------------------------------------------------------------------------------------------------------------------

Repetições/Laços em JavaScript	(um tipo de estrutura de controle)

-conhecidas como "loops", são mecanismos em programação que permitem executar um bloco de código repetidamente enquanto uma determinada condição for verdadeira.

-Estrutura de repetição com teste lógico no início (while): executa um bloco de código enquanto uma condição for verdadeira. Se a condição for falsa, ele não será 
executado nenhuma vez.

	var c = 1				-> variável criada para funcionar como contador. Vai indicar a quantidade de repetições
	while (c<=6){				-> Enquanto (while)  a variável c for menor ou igual a seis vai repetir o bloco seguinte
		console.log(`Passo ${c}`)	-> mostra a frase contendo um placeholder no node.js
		c++				-> comando que indica o aumento no valor da variável c em 1 à cada repetição (até chegar a seis)
	}

-Estrutura de repetição com teste lógico no final(do/while): similar ao while, mas garante que o bloco de código seja executado pelo menos uma vez.

	var c = 1				
	do{	
		console.log(`Passo ${c}`)	
		c++
	} while (c<=6)				
						
-Estrutura For: utilizado quando se sabe o número exato de interações que serão realizadas.

	for(início; teste; incremento){
		bloco de códigos
	}

	.seguindo o modelo utilizado anteriormente
	
		for(var c =1; c>=10; c++){
			console.log(`Passo ${c}`)
		}

Obs: utilize a ferramenta do desenvolvedor na página web (F12) para verificar se cada passo de coda função está funcionando corretamente. Utilize o "console.log("OK"), por
exemplo, no seu código .js e observe se, ao realizar a ação, na sua ferramenta do desenvolvedor aparece o "OK" especificado lá no seu código JavaScript.

--------------------------------------------------------------------------------------------------------------------------------------------------------------	
Lista de comandos JavaScript

-document.getElementById('id'):	refere a elemento com id especificada no parênteses
-Number(var.value):		transforma em número o valor de determinada variável	
-window.alert(''):		apresenta um alerta na tela
-id.innerHTML:			altera o conteúdo de determinado elemento HTML com o id especificado
-document.createElement('div'):	cria determinado elemento HTML via JavaScript

	.var item = document.createElement('option'):	ao atribuir a uma variável determinado elemento HTML ('option', no caso), é possível manipulá-lo por meio dela:
	
		item.text='exemplo':	atribui o texto 'exemplo' à variável item, a qual representa o elemento 'option'
		item.value='exemplo:	atribui o valor 'exemplo' à variável item, a qual representa o elemento 'option'

-id.appendChild(div):		cria um elemento filho em determinado elemento especificado pelo sei id 
-location.reload():		recarrega a página
-estilizar por meio do javascript:

	.id.style.border = '1px, solid, black':	acrescenta borda ao elemento com o id especificado
        .id.style.borderRadius = '10px':	acrescenta borda arredondada ao elemento com id especificado

-id.value='':			estabelece o valor do do elemento com id especificado como 'vazio'. Isso pode ajudar a 'limpar' o elemento caso precise realizar ação
				mais de uma vez.
-id.focus():			foca o cursor em determinado elemento especificado por sua id sem haver a necessidade de clicar novamente	
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Vetor (array): uma variável que pode receber mais de um valor (aula15/ambiente.js)

-vetores são estruturas de dados que nos permitem armazenar múltiplos valores sob uma única variável. Cada elemento poder ser de qualquer tipo de dado (números, 
strings, objetos, etc). Ex.:

	const frutas = ["maçã","banana","laranja"]	--> declaração
	console.log(frutas[0]);				--> acesso
	frutas[1] == "pêra"				--> modificação (agora o espaço 1 será ocupado por "pêra", ficando ["maçã","pêra","laranja"])

Métodos para adicionar e remover elementos em array

const frutas = ["maçã","banana"]

-push():	adiciona um ou mais elementos no final da array 	--> ["maçã","banana", "laranja"]
-pop():		remove e retorna o último elemento da array		--> ["maçã","banana"]
-shift():	remove e retorna o primeiro elemento da array		--> ["banana"]
-unshift():	adiciona um ou mais elementos ao início da array	--> ["uva","banana"]

Comandos para arrays

-frutas.length:			vai indicar o comprimento (atributo) da array a. O resultado vai ser 2 para 
-frutas.sort():			organiza (método) o conteúdo em ordem crescente (em caso de números) e em ordem alfabética (em caso de textos)
-frutas.indexOf(banana):	comando para buscar a posição do valor "banana" na array que no caso é "1"

-let a = [5, 7, 6]
	  0, 1, 2
	
	.vetor a
	.índices(chaves): 0, 1 e 2 (posição de cada elemento na array)
	.elementos (quantidade): 3
	.valor de cada elemento: 5, 7 e 6

-a[3] = 2 ou a.push(2):		vai adicionar na posição "3" (após o conteúdo '6') o conteúdo '2'. No caso do "push" ele também será acrescentado, porém, 
				obrigatoriamente na última posição

	.o novo vetor a será [5, 7, 6, 2]

-a.length:	vai indicar o comprimento (atributo) da array a. O resultado vai ser 4
-a.sort():	organiza (método) o conteúdo em ordem crescente

	.o novo vetor 'a' será [2, 5, 6, 7]

-for(let pos in a){		--> "para cada posição em a o sistema mostrará o a[pos]"
	console.log(a[pos])
}

	."pos (posição)" é a variável criada para o contador
	. "in" faz parte dessa estrtura "for" que pode substituir em caso de vetores e objetos
	."a" é a variável vetor criada (let a = [5, 7, 6]) 
	."console.log" é o comando para mostrar algo no NODE
	."a[pos]" especificação para mostrar o valor (conteúdo) de determinada posição. Como é um laço de repetição, a variável "pos" aumentará de um por um, alterando o valor
	da posição e consequentemente o conteúdo mostrado
	.O que será mostrado então é "5 7 6"

-a.indexOf(7):				comando para buscar a posição do valor "7" na array que no caso é "1"
-a.filter(numPar => numPar%2=0):	filtar os elementos do array com base em algo. Nesse caso, com base em ser par (especificado na função anônima com argumento
					'numPar'
-a.reduce():				C:\Users\Filipe\Documents\Dev\EBAC\Estudos\Front-end\javascript\EBAC\exercicios_fixacao150525\fixacao15_somarTodosElementos.js

--------------------------------------------------------------------------------------------------------------------------------------------------------------
Funções (C:\Users\Filipe\Documents\Dev\EBAC\Estudos\Front-end\javascript\EBAC\exercícios_função) - para revisão

-são ações executadas assim que são chamadas o u em decorrência de algum evento. Uma função pode receber parâmetros e retornar um resultado. Cada função 
executa apenas 1(um) return, apesar de pode haver dentro dela mais de um. (aula16/funcao01.js)

-chamada: 11
-parâmetro: n
-ação: if(){}
-retorno: ímpar

	function parimp(n){		--> função criada para verificar se um número é par ou ímpar
		if(n%2==0){		--> condicional que caracteriza um número par(se o resto da divisão do número em análise por dois for igual a zero, então é par
		return 'par'		--> caso seja verdadeira a condicional, retorna 'par'
		} else{
			return 'ímpar'	--> caso contrário, retorna 'ímpar'
		}

	}
	
	let res = parimp(11)		--> a chamada aqui vai ser "11" que será utilizado lá na função "parimp"
	console.log('res')		--> vai mostrar "ímpar"

Obs: existem duas possibilidades básicas de representar uma função

	1.
		function saudacao(nome){
			console.log('Olá' + nome + '!');	--> utilizando oparâmentro concatenado com texto
		}

	2.
		function saudacao(nome){
			console.log(`Olá ${nome}!`;		--> utilizando um placeholder (${}) entre crases (``)
		}

Retorno

-retornando um parâmetro específico ("Ronaldo", nesse caso):

	//cria a função
	function saudacao(nome){
		return(`Olá, ${nome}!`);			--> utilizando um placeholder (${}) entre crases (``)
	}

	//pega o retorno / invoca a função
	const mensagemSaudacao = saudacao("Ronaldo");

	//exibe Olá, Ronaldo!
	alert(mensagemSaudacao);			--> função global para mostrar mensagem na página web

	OU

	//cria a função
	function saudacao(nome){
		return(`Olá, ${nome}!`);			
	}

	//exibe Olá, Ronaldo!
	alert(saudacao("Ronaldo"));			--> chama a função saudacao() já dentro da função alert()

-encerrando uma função

	//cria a função
	function divisao(dividendo, divisor){

		if(divisor == 0){
			return "Não é possível dividir por zero";
		}

		if(divisor == 1){
			return dividendo;
		}

		return dividendo / divisor;
	}

	//invoca a função
	console.log(divisao(42,0));	// Não é possível dividir por zero
	console.log(divisao(42,1));	//42
	console.log(divisao(42,2));	//21

Obs: em condicinais "if" que apresentam apeans uma linha de código, é possível escrevê-las sem as chaves sem maiores prejuízos.

Funções anônimas

-funções que não possuem um nome declarado. No lugar, cria-se uma variável e atribui-se a ela uma função sem nome:

	//cria a função
	const divisao = function(dividendo, divisor){			--> variável "divisao" criada e atribuída à ela uma função sem nome

		if(divisor == 0){
			return "Não é possível dividir por zero";
		}

		if(divisor == 1){
			return dividendo;
		}

		return dividendo / divisor;
	}

	//invoca a função
	console.log(divisao(42,0));	// Não é possível dividir por zero
	console.log(divisao(42,1));	//42
	console.log(divisao(42,2));	//21

-função anônmima "autônoma": uma função sem nome que sempre será executada

	(function(){					--> função sem nome
		alert("Bem-vindo ao meu site.");
	})();						--> abrindo e fechando os parênteses no final chama a função novamente

-Arrow Functions: não declarada (utiliza variável), sem a palavra "function" e sem return. O resultado vai aparecer para quem chamar essa função. É a maneira mais 
curta de se criar uma função. Muito utilizada com o métdo find(), no qual busca-se determinado elemento em uma array.

	//cria a função
	const quadradoDo = (num1) => {		--> apresenta a "arrow function (=>)"
		return num1 * num1;	
	}

	console.log(quadradoDo(6)) // 36

Obs: se houver apenas uma linha de retorno, é comum escrever tudo em uma linha apenas, como "const quadradoDo = (num1) => num1 * num1;" sem as chaves e a palavra 
return.

Obs: o "()=>" substitui o "function()".

-Immediately Invoked Function Expression (IIFE): é uma função anônima que é executada imediatamente após ser definida

	(function(){
		console.log("Esta função é executada imediatamente!");
	}();								--> sua característica principal são os parênteses ao final

	//versão arrow function
	(()=>{
		console.log("Esta função também é executada imediatamente!");
	}();									--> sua característica principal são os parênteses ao final					

Composição de funções

	//funções das 4 operações básicas
	const soma = (a,b) => a + b;				--> "a + b" é o return
	const subtracao = (a,b) => a - b;
	const multiplicacao = (a,b) => a * b;
	const divisão = (a,b) => b>0? a/b: NaN;			--> se "b" for maior que 0, então realiza a divisão. Se não, Not a Number.

	//função de cálculo
	const calculo = (operacao,a,b) => operacao(a,b);	--> composição de função. Dentro de uma função anônima existe como parâmetro outra função (arrow)

	//usando a função
	const resposta =  calculo(soma,21,21)

--------------------------------------------------------------------------------------------------------------------------------------------------------------
Objetos: permitem diversos identificadores (atributos) ao invés de apenas 0, 1, 2 (índices ou chaves) e etc nos arrays (vetores). Podem guardar valores e 
funcionalidades (métodos). São identificados pelo uso de chaves:

let amigo = {nome:'José', sexo:'M', peso:85.4, engordar(p){}}

	.nome:		atributo (valor)
	.José:		conteúdo (string)
	.sexo:		atributo (valor)
	.M:		conteúdo (string)
	.peso:		atributo (valor)
	.85.4:		conteúdo (número)
	.engordar(p):	função   (funcionalidade)

Conceitos fundamentais da Programação Orientada ao Objeto: POO é um paradigma bem como progamação funcional

-Tipos de dados

	.classes 
	.objetos anônimos
	.definições de tipos específicos

	1-Classes: modelo ou molde que define as propriedeades (características) e métodos (comportamentos) que um objeto pode ter.Ex.:

		.classe:	carta de baralho
		.atributo(s):	valor e naipe
		.método:	mostraCartas():void
		
		Caratcterísticas de classes

		.define um tipo: serve como um modelo para criar novos tipos de dados personalizados.
		.determina as características: especifica as propriedades que os objetos desse tipo terão.
		.define comportamentos: define os métodos que os objetos desse tipo podem executar
		.gera objetos: a partir de uma classe, podemos criar inúmeros objetos, cada um com seus prórpios dados únicos.

		Método construtor
		.o coração de uma classe no javascript está no seu construtor. É nele que definimos as características básicas de um objeto que será criado a partir 
		dessa classe.
		.inicialização: o método construtor é responsável por inicializar os atributos (propriedades) do objeto no momento da criação.
		.atribuição de valores: é no método construtor que passamos os valores iniciais para esses atributos, ou seja, os dados que cada objeto individual 
		terá.
		.define cmportamentos: define os métodos que os objtos desse tipo podem executar.
		.diferenças entre linguagens: embora o javascript centralize a declaração de atributos e métodos no construtor, outras linguagens como java e C# 
		separam essas declarações.

Obs: "métodos" são funções dentro de classes de objetos, mas são chamados assim por dois motivos:

	.por estar no contexto POO e no interior de uma classe
	.por ele poder manipular o estado interno de um objeto

		Métodos de acesso: por boas práticas, alterações a serem realizadas em atributos dentro de objetos são realizadas por método, ou seja, por meio de 
		funções como getValor():string ou getNaipe():string, utilizando o exemplo do baralho de cartas, esses atributos seriam alterados.

		Herança e polimorfismo: uma classe pode dar origem à outa classa, como uma classe pessoa gerar as classes "cliente" e "colaborador", as quais guardam
		tanto atributos semelhantes quanto diferentes entre si. No caso, a classe "pessoa" reuni todos os atributos que tanto as pessoas "clientes" quanto as
		pessoas "colaboradores" devem ter, sendo que "cliente" e "colaborador" vão acrescentar (especializar) características particulares de cada um sem 
		precisar criar outras duas classe com atributos semelhantes à "pessoa". O polimorfismo versa justamente sobre essa possibilidade da classe "pessoa" ser
		ao mesmo tempo "cliente" e "colaborador".

Paradigma da Programação Funcional em JavaScript

	.foco em funções: funções são cidadãs de primeira classe, podendo ser atribuídas a variáveis, passadas como argumentos e retornadas por outras funções.
	.imutabilidade: dados são geralmente imutáveis, ou seja, não são alterados após a criação. Isso ajuda a evitar efeitos colaterais e torna o código mais 
	previsível.
	.pureza: funções puras não causam efeitos colaterais e sempre retornam o mesmo resultado para os mesmos argumentos.
	.higher-order functions: funções que aceitam outras funções como argumentos ou retornam funções. Exemplos: map, filter, reduce.

Paradigma da Programação Orientada a Objetos(POO)

	.foco em objetos: o código é organizado em torno de objetos que possuem propriedades (dados) e métodos (comportamentos)
	.herança: objetos podem herdar propriedades e métodos de outros objeots, criando hierarquias de classes
	.encapsulamento: esconde a implementação interna de um objeto, expondo apenas uma interface pública
	.polimorfismo: permite que objetos de diferentes classes sejam tratados como se fossem do mesmo tipo
	
		
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Tipos de erros comuns

1. esquecer e iniciar variáveis

	ex.:	let total;
		total+=10; // erro: total não foi inicializada

		let total=0
		total += 10; // 10

2.uso incorreto de operadores de comparação: confundir operadores de atribuição (=) com operadores de comparação (== ou ===) é um erro comum que pode levar a bugs 
lógicos.

3.esquecer de usar o 'break' em instruções 'switch': não usar o 'break' em cada caso de um 'switch' pode levar a um comportamento de 'fall-through', onde múltiplos 
casos são executados.

	ex.:	switch (day) {
  			case 1:
    				console.log("Monday");
  			case 2:
    				console.log("Tuesday");
		}


		switch (day) {
  			case 1:
    				console.log("Monday");
    				break;
  			case 2:
    				console.log("Tuesday");
    				break;
		}

4.não usar corretamente o escopo de variáveis: declarar variáveis no escopo errado pode levar a erros de referência ou comportamento inesperado.

5.esquecer de retornar valores em funções: iniciantes podem esquecer de usar a palavra-chave 'return' em funções que devem devolver um valor, resultando em 
'indefined'.	

	ex.:	function sum(a, b) {
  			let result = a + b;
  		// Esqueceu de retornar o resultado
		}
		console.log(sum(2, 3)); // undefined

		function sum(a, b) {
  			let result = a + b;
  			return result;
		}

		console.log(sum(2, 3)); // 5
